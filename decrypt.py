import random
import math
import re
from collections import Counter

# ------------------------------
# Mapping utilities
# ------------------------------
def apply_mapping(text, mapping):
    out = []
    for ch in text:
        up = ch.upper()
        if up in mapping:
            mapped = mapping[up]
            if ch.islower():
                out.append(mapped.lower())
            else:
                out.append(mapped)
        else:
            out.append(ch)
    return ''.join(out)

def load_ngrams(path):
    model = {}
    total = 0
    with open(path, encoding="utf8") as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) != 2:
                continue
            gram, count = parts
            model[gram] = int(count)
            total += int(count)
    return model, total

def random_mapping():
    letters = list("ABCDEFGHIJKLMNOPQRSTUVWXYZ")
    shuffled = letters[:]
    random.shuffle(shuffled)
    return dict(zip(letters, shuffled))

def swap_mapping(mapping):
    new_map = mapping.copy()
    a, b = random.sample(list(new_map.keys()), 2)
    new_map[a], new_map[b] = new_map[b], new_map[a]
    return new_map

# ------------------------------
# Mini N-gram datasets
# ------------------------------
unigrams, _ = load_ngrams("english_unigrams.txt")
bigrams, _  = load_ngrams("english_bigrams.txt")
trigrams, _ = load_ngrams("english_trigrams.txt")
quadgrams, _= load_ngrams("english_quadgrams.txt")

# ------------------------------
# N-gram scorer class
# ------------------------------
class NgramScorer:
    def __init__(self, datasets, weights=None):
        self.models = {}
        self.log_probs = {}
        self.floors = {}
        self.weights = weights or {}
        for n, model in datasets.items():
            total = sum(model.values())
            logp = {}
            for gram, c in model.items():
                logp[gram] = math.log10(c / total)
            self.models[n] = model
            self.log_probs[n] = logp
            self.floors[n] = math.log10(0.01 / total)
            if n not in self.weights:
                self.weights[n] = 1.0

    def score(self, text):
        text = re.sub('[^A-Z]', '', text.upper())
        total_score = 0
        for n in self.models:
            logp = self.log_probs[n]
            floor = self.floors[n]
            score = 0
            for i in range(len(text) - n + 1):
                gram = text[i:i+n]
                score += logp.get(gram, floor)
            total_score += self.weights[n] * score
        return total_score

# ------------------------------
# Ciphertext
# ------------------------------
CIPHERTEXT = "CGVDVXUATQAGAIGATQGAAFIRHTVHUGOPOAPJIGUPJAMFVGDMTQAGAIGATQGAAFIRHTVHUGOPOAPJIGUPJAMFVGDMJVFPQIOAKVGXVTTAJIKAFZUTVJATQPJXPHYAGTIPJTQAKIYTTQITRVUFQVIGAGAIMPJXTQPHJVFFPDDHUGOPOATQGAAFIRHTVHUGOPOAPJIGUPJAMFVGDMIFAZJVOADCDITKVGNKPDDAMTQAHYGAAJVKNRVDMHNIGTCQVJAPHYGVDDAMMVFJIJMTQAJUCIXIPJQVFNIJRTPNAHQIOAPZAAJMVPJXTQPHGAIDDRTQPHPHTQAAJMPDVVLAMIXIPJIJMTQAYVNCDATAFIHUJNPHTILIZDATQAHTVGRFIHVOAGTQGAAFIRHTVHUGOPOAPJIGUPJAMFVGDMIUTQVGTDHYQICTAGHTQGAAFIRHTVHUGOPOAPJIGUPJAMFVGDMFIHIKAITUGADAJXTQKIJTIHRJVOADFPTQYQICTAGHPTHHQVGTAJAMJINAFIHFIRHVKHUGOPOIDPQIOAZAAJHTAIMPDRGAIMPJXTQPHJVOADHPJYATQATQPGMRAIGVKNPMMDAHYQVVDMUGPJXTQATPNAFQAJPFIHZUDDPAMZRPDEPJHFQAJPGUPJAMNRAJTGIJYAABINPJITPVJHIJMQIMTVAJTAGIDVYIDUJPOAGHPTRFQAJTQAMINJAMGIJMVNMGIFFAJTFGVJXIJMPFIHCDIYAMPJTQANPDPTIGRUJPTITTQAKVGAKGVJTFQAJPGACAITAMDRHFPTYQAMEVZHIJMINJVFFVGLPJXIHIYVJTGIYTVGKVGIJIKKPDPITAVKIDIGXAYVNCIJRMINJDATHHTVCTIDLPJXIZVUTTQPHIJRFIRIUTQVGHFVGMHTQIJLRVUHVNUYQKVGGAIMPJXFIRHVKHUGOPOIDUCTVQAGAPFPDDYVNAZIYLTVRVUFPTQIJACPDVXUAIQTQAACPDVXUAHTPDDGANIPJHTQAJTQAJABTYQICTAGPHGAIDDRTQADIHTVJAKGVNTQAAJMVKYQPDMQVVMTVIMUDTQVVMPTQIMZAAJMVJAVOAGIQUXACAGPVMVKRAIGHTQAGAFIHINPBTUGAVKMAHCVJMAJYRTQITIFVGDMFIHYVNPJXTVIJAJMIDVJXFPTQIHAJHAVKHITPHKIYTPVJPVCAJAMTQAYVNNAJTZVBVKTQADIHTNAHHIXAIJMGAFGVTATQAHAJTAJYAHAOAGIDTPNAHLPNMVLEIFGPTAGTQIJLRVUKVGAOAGRTQPJXPJTQANAIJTPNAPINDVVLPJXKVGFIGMTVTQAACPDVXUATQARFAGAHPJYAGAHAJTAJYAHFIRHVKHUGOPOIDFIHNRDPKAHJVOADPTFIHJTTQANVHTCVCUDIGZUTPTFIHTQAZAHTJVOADKVGNATQAGAFAGANIJRFVGMHPFIJTAMTVHIRZUTPYVUDMJTFGPTATQANPFIHIKGIPMTQITNRYIGADAHHFVGMHFVUDMQUGTTQAFGPTAGIJIOAGIXAVKQPTHCAGYQICTAGIJIOAGIXAVKYVNNAJTHTQPHFIHTQAIOAGIXACVCUDIGPTRPJMABVKFIRHVKHUGOPOIDTQAJUNZAGVKOPAFHKVGTQAKPGHTYQICTAGFIHZUTPTKADDTVKVGTQATQYQICTAGIJMTQAJKVGTQATQYQICTAGZRTQATPNAPTFIHTQATQYQICTAGPTFIHVJDRQPTHPFIHVOAGFQADNAMZRTQAKAADPJXPXVTFQAJPHIFTQAJUNAGVUHTQITICCAIGAMJABTTVTQADPHTVKYQICTAGHPJHVNAYIHAHTQAGAFIHIZUTPTFIHDPLADRHVNAVJACGAHHPJXTQAFGVJXZUTTVJTQIJLRVUTQAIUTQVGCUZDPHQAMIJVOADFPTQNVGATQIJYQICTAGHFPTQEUHTQPTCAGYQICTAGVOAGICAGPVMVKRAIGHPTFIHTGUDRIHTVGREUHTKVGNAPCGAHHAMVJTQAGAYVNNAJMITPVJZVIGMIJMPNNAMPITADRHTIGTAMTICCPJXVJTQALARZVIGMPINGAYVNNAJMPJXIQVJAREINJVOADTQAIUTQVGFGVTANAIKGAAYVNCDATAMJVOADHVPHQVUDMXPOAQPNIGAYVNNAJMITPVJPYDPYLAMVJTQAYVNCDATAMZUTTVJIJMYVNNAJTHWUPYLDRICCAIGAMPTDVVLHDPLAIJAFIJTPPHAIGYQAMKVGTQPHCAGHVJHPMIJMTQARGAYVNNAJMAMTQAHINAJVOADHAOAGIDTPNAHPHJTQPHGAYVNNAJMITPVJZIJJAMTQAIUTQVGHQVUDMJTMVTQPHQAGAPTVYYUGGAMTVNATQITPQIMFGPTTAJIGAYVNNAJMITPVJHAOAGIDNVJTQHIXVPJIJPJHTIJTTQAGAFAGAMVSAJHVKYVNNAJTHKVGPJOAHTPXITPVJZRHCAYTITVGHNRKIYAKDUHQAMFPTQANZIGGIHHNAJTPFIHHUGATQITTQAIUTQVGFVUDMGAIMTQPHHVPQUGGPAMDRTGPAMTVMADATATQANAHHIXAZUTPTFIHIDGAIMRGACVGTAMTQITTQANAHHIXAYVUDMJTZAGANVOAMTQPHPTFIHUCHATTPJXTVTQPJLTQITTQAGAYVNNAJMITPVJFGPTTAJFPTQIDDNRHPJYAGPTRTUGJAMVUTDPLATQPHPKTQARAOAJDVVLAMIDPTTDAZPTFQRMPMJTIJRVJATGRGAIMPJXTQAPJTAGAHTPJXJVOADPFIJTAMTVXPOAIMVJITPVJTVTQAFGPTAGZUTPYVUDMJTIKKVGMPTZAYIUHAPFIHIHIDIGRFVGLAGZIGADRIZDATVNILAIDPOPJXTQAJPGAYAPOAMIJVTPKPYITPVJTQITINAHHIXAQIHIGGPOAMTDHTQIJLRVUINAHHIXAKDAFPJKGVNVUTVKJVFQAGAPTTVVLNAIFQPDATVXGIHCTQAHPTUITPVJLPNMVLEITQAIUTQVGTDHPTFIHTQAIUTQVGVKFIRHVKHUGOPOIDTDHPFIHIZDATVYVNCDATAPTTVTQAAJMTQIJLHTVRVUPIDHVFVJTQAYVNCATPTPVJPYVUDMJTZADPAOAPTFIRHVKHUGOPOIDFVJIYVNCATPTPVJLPNMVLEIYVJXGITUDITPVJHFQITPHTQAYVNCATPTPVJTDHRVUFVJTLJVFPTZAYIUHAPTPHIJUJLJVFJYVNCATPTPVJPFVJMAGAMPKQADPAMZAYIUHAQAFIHIHQINAMZUTPFIJTAMPTTVZATGUACAGQICHPGAIDDRMPMJTLJVFPTNPXQTZAIZPTQPTVJVTQAGCDITKVGNHPFIHIDPTTDAHIMZUTPTFIHXVVMTVQIOAIJABYADDAJTHTVGRHCGAIMPJXTDHPFVUDMDPLATVHAJMIHCAYPIDXPKTTVRVUIHITQIJLRVUMVYLPNXPKTTDHPTPHTQIJLHTVNRMAIGGAIMAGTQITTQPHHTVGRQIHYVNAPJTVTQAFVGDMPXIOATQAFGPTAGNRANIPDIMMGAHHIHQAIHLAMTDHIQGPXQTPXVTTQANVJATPSITPVJHYQAMUDALPNMVLEIFVFGAIDDRFQAJFPDDPTHTIGTTQPHNIHTAGCPAYAHQVUDMOAZAAJCIPMKGVNTQAZAXPJJPJXPTFIHIDPATQAFIRHVKHUGOPOIDFIHIMIPDRHAGPAHHVPFVUDMOAQIMTVHCAJMFVJINVJTQFVJFIHVJAYVJOAJPAJYAHTVGADUJYQKVGNATDHTQANVJATPSITPVJHTIGTHTVNVGGVFLPNMVLEITQAJTQAACPDVXUAYVNPJXTVNVGGVFFPDDZACIPMTDHRAHPNIKGIPMRVUJAAMTVCIRKVGPTLPNMVLEIVKYVUGHAPQIOATVCIRPFPDDZURTQADIHTVJATQAGAFIHJVGACDRKGVNTQAIUTQVGIKTAGFIGMPDVXXAMVUTVKTQAHPTATQAJPKADTTQACAHHPNPHNHPJLPJDITAGTQAIUTQVGDAKTFPTQVUTIGACDRIKTAGQAHUYYAAMAMNRIMNPGITPVJTUGJAMPJTVCATTREAIDVUHRFQITFIHPHVABYPTAMKVGPJIJRYIHAPTFIHJTNRJVOADFPDDQAXPOAIXPKTYAGTPKPYITAPTFVUDMZAXVVMPKPTHKVGFVJITTQITTPNAPFIHTQPJLPJXJIPOADRPMPMJTLJVFIJRTQPJXIZVUTFQITFVUDMQICCAJTVTQAFVGDMTQAJABT"  # potong untuk demo

letters_only = re.sub('[^A-Z]', '', CIPHERTEXT)

# ------------------------------
# Setup Scorer
# ------------------------------
datasets = {
    1: unigrams,
    2: bigrams,
    3: trigrams,
    4: quadgrams
}
weights = {1:0.5, 2:1.0, 3:2.0, 4:4.0}
scorer = NgramScorer(datasets, weights)

# ------------------------------
# Hillclimbing Search
# ------------------------------
best_map = random_mapping()
best_score = scorer.score(apply_mapping(letters_only, best_map))

for iteration in range(100000):  # semakin tinggi semakin baik
    new_map = swap_mapping(best_map)
    new_score = scorer.score(apply_mapping(letters_only, new_map))
    if new_score > best_score:
        best_map, best_score = new_map, new_score
        if iteration % 5000 == 0:
            print(f"[{iteration}] score={best_score:.2f}")
            print(apply_mapping(CIPHERTEXT, best_map)[:200], "...\n")

print("=== Final Decryption (partial) ===")
print(apply_mapping(CIPHERTEXT, best_map)[:1000])